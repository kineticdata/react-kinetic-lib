{"version":3,"sources":["/Users/shayne/Work/react-kinetic-lib/src/components/form/defaults/Components.mdx"],"names":["layoutProps","MDXLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"yZAYMA,G,+EAAc,IAGdC,EAAY,UACH,SAASC,EAAT,GAGX,IAFFC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACH,EAAD,iBAAeD,EAAiBI,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAE5E,iBAAQ,CACN,GAAM,2BADR,2BAGA,gKAEA,sFAAqE,+BAAGC,WAAW,KAAQ,CACvF,KAAQ,wCADyD,aAArE,KAGA,iBAAQ,CACN,GAAM,cADR,cAGA,mFAAkE,0BAAYA,WAAW,KAAvB,eAClE,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,cACb,WAAc,SACd,QAAU,IAHT,qkKAsKL,iBAAQ,CACN,GAAM,YADR,YAGA,iFAAgE,0BAAYA,WAAW,KAAvB,aAChE,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kbAkBL,iBAAQ,CACN,GAAM,YADR,YAGA,iFAAgE,0BAAYA,WAAW,KAAvB,aAChE,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,+aAkBL,iBAAQ,CACN,GAAM,SADR,SAGA,8EAA6D,0BAAYA,WAAW,KAAvB,UAC7D,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mjBAuBL,iBAAQ,CACN,GAAM,UADR,UAGA,+EAA8D,0BAAYA,WAAW,KAAvB,WAC9D,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qlBAwBL,iBAAQ,CACN,GAAM,QADR,QAGA,6EAA4D,0BAAYA,WAAW,KAAvB,SAC5D,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,slB,iMA4BTJ,EAAWK,gBAAiB","file":"static/js/components-form-defaults-components.f89760aa.js","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\nimport { Props } from 'docz';\nimport { Field, typeToComponent } from '../Field';\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1 {...{\n      \"id\": \"default-form-components\"\n    }}>{`Default Form Components`}</h1>\n    <p>{`The following components are simply default components and cannot be imported.\nThese are examples of components that you can override.`}</p>\n    <p>{`All fields receive the same props which are documented on the `}<a parentName=\"p\" {...{\n        \"href\": \"/react-kinetic-lib/form#field-props\"\n      }}>{`Form Page`}</a>{`.`}</p>\n    <h2 {...{\n      \"id\": \"attributes\"\n    }}>{`Attributes`}</h2>\n    <p>{`The Default Attributes Field rendered when a field type is `}<inlineCode parentName=\"p\">{`attributes`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\",\n        \"metastring\": \"static\",\n        \"static\": true\n      }}>{`import React, { Component, Fragment } from 'react';\nimport { List, Map, Repeat } from 'immutable';\n\nexport class AttributesField extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { added: List(), adding: '' };\n  }\n\n  // returns the number of attribute values that were previously set\n  countPrevious = name =>\n    this.props.value.get(name).size - this.countAdded(name);\n\n  // returns the number of attribute values that have been added\n  countAdded = name => this.state.added.filter(n => n === name).size;\n\n  onRemove = (name, index) => () => {\n    const addedIndex = index - this.countPrevious(name);\n    if (addedIndex >= 0) {\n      this.setState(state => ({\n        added: filterWithOccurrences(\n          state.added,\n          (n, i) => n !== name || i !== addedIndex,\n        ),\n      }));\n    }\n    this.props.onChange(this.props.value.deleteIn([name, index]));\n  };\n\n  onInputChange = (name, index) => event => {\n    const value = event.target.value;\n    if (!this.props.value.hasIn([name, index])) {\n      this.setState(state => ({\n        added: state.added.push(state.adding),\n        adding: '',\n      }));\n    }\n    this.props.onChange(\n      this.props.value.update(name, List(), values => values.set(index, value)),\n    );\n  };\n\n  onSelectChange = event => {\n    this.setState({ adding: event.target.value });\n  };\n\n  render() {\n    const attributes = mapWithOccurrences(\n      this.props.value\n        .keySeq()\n        .sort()\n        .flatMap(name => Repeat(name, this.countPrevious(name)))\n        .concat(this.state.added.push(this.state.adding)),\n      (name, index) => ({\n        name,\n        index,\n        value: this.props.value.getIn([name, index], ''),\n      }),\n    );\n    return (\n      this.props.visible && (\n        <Fragment>\n          <h5>{this.props.label}</h5>\n          <table>\n            <thead>\n              <tr>\n                <th>Name</th>\n                <th>Value</th>\n                <th />\n              </tr>\n            </thead>\n            <tbody>\n              {attributes.size === 1 && this.props.placeholder && (\n                <tr>\n                  <td colSpan={3}>\n                    <em>{this.props.placeholder}</em>\n                  </td>\n                </tr>\n              )}\n              {attributes.map(({ name, value, index }, i) => (\n                <tr key={i}>\n                  <td>\n                    {i < attributes.size - 1 ? (\n                      name\n                    ) : (\n                      <select onChange={this.onSelectChange} value={name}>\n                        <option hidden />\n                        {availableAttributes(\n                          this.props.options,\n                          this.props.value,\n                        ).map(option => (\n                          <option key={option} value={option}>\n                            {option}\n                          </option>\n                        ))}\n                      </select>\n                    )}\n                  </td>\n                  <td>\n                    <input\n                      type=\"text\"\n                      value={value}\n                      onFocus={this.props.onFocus}\n                      onBlur={this.props.onBlur}\n                      onChange={this.onInputChange(name, index)}\n                    />\n                  </td>\n                  <td>\n                    {i < attributes.size - 1 && (\n                      <button\n                        type=\"button\"\n                        onFocus={this.props.onFocus}\n                        onBlur={this.props.onBlur}\n                        onClick={this.onRemove(name, index)}\n                      >\n                        &times;\n                      </button>\n                    )}\n                  </td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </Fragment>\n      )\n    );\n  }\n}\n\n// Helper function that maps for a List but instead of providing the index in\n// the overall list, it gives the lambda the count of the occurrences of current\n// value that have already occurred in the list.\n// For example: ['red', 'green', ''red',]\n// Would call: ['red,' 0], ['green', 0], ['red', 1], ['blue', 0]\nconst mapWithOccurrences = (list, mapper) =>\n  list.reduce(\n    ([result, counts], current) => [\n      result.push(mapper(current, counts.get(current, 0))),\n      counts.update(current, 0, count => count + 1),\n    ],\n    [List(), Map()],\n  )[0];\n\n// Same idea as mapWithOccurrences above.\nconst filterWithOccurrences = (list, pred) =>\n  list.reduce(\n    ([result, counts], current) => [\n      pred(current, counts.get(current, 0)) ? result.push(current) : result,\n      counts.update(current, 0, count => count + 1),\n    ],\n    [List(), Map()],\n  )[0];\n\nconst availableAttributes = (options, value) =>\n  options\n    .filter(\n      option =>\n        option.get('allowsMultiple') ||\n        value.get(option.get('name'), List()).isEmpty(),\n    )\n    .map(option => option.get('name'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"checkbox\"\n    }}>{`Checkbox`}</h2>\n    <p>{`The Default Checkbox Field rendered when a field type is `}<inlineCode parentName=\"p\">{`checkbox`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`export const CheckboxField = props =>\n  props.visible && (\n    <div className=\"field\">\n      <input\n        type=\"checkbox\"\n        id={props.id || props.name}\n        name={props.name}\n        checked={props.value || false}\n        onBlur={props.onBlur}\n        onChange={props.onChange}\n        onFocus={props.onFocus}\n      />\n      <label htmlFor={props.id || props.name}>{props.label}</label>\n    </div>\n  );\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"password\"\n    }}>{`Password`}</h2>\n    <p>{`The Default Password Field rendered when a field type is `}<inlineCode parentName=\"p\">{`password`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`export const PasswordField = props =>\n  props.visible && (\n    <div className=\"field\">\n      <label htmlFor={props.id || props.name}>{props.label}</label>\n      <input\n        type=\"password\"\n        id={props.id || props.name}\n        name={props.name}\n        value={props.value || ''}\n        onBlur={props.onBlur}\n        onChange={props.onChange}\n        onFocus={props.onFocus}\n      />\n    </div>\n  );\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"radio\"\n    }}>{`Radio`}</h2>\n    <p>{`The Default Radio Field rendered when a field type is `}<inlineCode parentName=\"p\">{`radio`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`export const RadioField = props =>\n  props.visible && (\n    <div className=\"field\">\n      <legend>{props.label}</legend>\n      {props.options.map(option => (\n        <label key={option.value}>\n          <input\n            name={props.name}\n            type=\"radio\"\n            value={option.value}\n            checked={props.value === option.value}\n            onChange={props.onChange}\n            onBlur={props.onBlur}\n            onFocus={props.onFocus}\n          />\n          {option.label}\n        </label>\n      ))}\n    </div>\n  );\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"select\"\n    }}>{`Select`}</h2>\n    <p>{`The Default Select Field rendered when a field type is `}<inlineCode parentName=\"p\">{`select`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`export const SelectField = props =>\n  props.visible && (\n    <div className=\"field\">\n      <label htmlFor={props.id || props.name}>{props.label}</label>\n      <select\n        id={props.id || props.name}\n        name={props.name}\n        value={props.value || ''}\n        onBlur={props.onBlur}\n        onChange={props.onChange}\n        onFocus={props.onFocus}\n      >\n        <option />\n        {props.options.map((option, i) => (\n          <option key={i} value={option.value}>\n            {option.label}\n          </option>\n        ))}\n      </select>\n    </div>\n  );\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"team\"\n    }}>{`Team`}</h2>\n    <p>{`The Default Team Field rendered when a field type is `}<inlineCode parentName=\"p\">{`team`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`export const SelectField = props =>\n  props.visible && (\n    <div className=\"field\">\n      <label htmlFor={props.id || props.name}>{props.label}</label>\n      <select\n        id={props.id || props.name}\n        name={props.name}\n        value={props.value || ''}\n        onBlur={props.onBlur}\n        onChange={props.onChange}\n        onFocus={props.onFocus}\n      >\n        <option />\n        {props.options.map((option, i) => (\n          <option key={i} value={option.value}>\n            {option.label}\n          </option>\n        ))}\n      </select>\n    </div>\n  );\n`}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;\n  "],"sourceRoot":""}